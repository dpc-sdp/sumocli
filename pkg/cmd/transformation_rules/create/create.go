package create

import (
	"fmt"
	"github.com/SumoLogic-Labs/sumologic-go-sdk/service/cip"
	"github.com/SumoLogic-Labs/sumologic-go-sdk/service/cip/types"
	"github.com/dpc-sdp/sumocli/pkg/cmdutils"
	"github.com/spf13/cobra"
	"os"
)

func NewCmdTransformationRulesCreate(client *cip.APIClient) *cobra.Command {
	var (
		addOrReplaceTransformationType bool
		aggregateOn                    []string
		aggregateOnTransformationType  bool
		dimensionToReplace             string
		enabled                        bool
		name                           string
		retention                      int64
		selector                       string
		transformedMetricsRetention    int64
		value                          string
	)
	cmd := &cobra.Command{
		Use:   "create",
		Short: "Create a new transformation rule.",
		Run: func(cmd *cobra.Command, args []string) {
			create(addOrReplaceTransformationType, aggregateOn, addOrReplaceTransformationType, client, dimensionToReplace,
				enabled, name, retention, selector, transformedMetricsRetention, value)
		},
	}
	cmd.Flags().BoolVar(&addOrReplaceTransformationType, "addOrReplaceTransformationType", false, "Set to true to use an add or replace transformation type. "+
		"If this is set to true --dimensionToReplace and --value need to be set.")
	cmd.Flags().StringSliceVar(&aggregateOn, "aggregationOn", []string{}, "Specify a comma separated list of dimensions that should be aggregated on. "+
		"Only required if --aggregateOnTransformationType is set to true.")
	cmd.Flags().BoolVar(&aggregateOnTransformationType, "aggregateOnTransformationType", false, "Set to true to use an aggregate on transformation type. "+
		"If this is set to true --aggregateOn needs to be set. ")
	cmd.Flags().StringVar(&dimensionToReplace, "dimensionToReplace", "", "Specify the dimension that needs to be modified or added. "+
		"Only required if --addOrReplaceTransformationType is set to true.")
	cmd.Flags().BoolVar(&enabled, "enabled", true, "Set to false to disable the transformation rule.")
	cmd.Flags().StringVar(&name, "name", "", "Specify the name of the transformation rule.")
	cmd.Flags().Int64Var(&retention, "retention", 400, "Specify the retention period in days for the metrics that are selected by the selector.")
	cmd.Flags().StringVar(&selector, "selector", "", "Specify the selector for the transformation rule.")
	cmd.Flags().Int64Var(&transformedMetricsRetention, "transformedMetricsRetention", 0, "Specify the retention period in days for the metrics that are generated by this rule.")
	cmd.Flags().StringVar(&value, "value", "", "Specify the value for the dimension. Only required if --addOrReplaceTransformationType is set to true.")
	cmd.MarkFlagRequired("name")
	cmd.MarkFlagRequired("selector")
	return cmd
}

func create(addOrReplaceTransformationType bool, aggregateOn []string, aggregateOnTransformationType bool, client *cip.APIClient,
	dimensionToReplace string, enabled bool, name string, retention int64, selector string, transformedMetricsRetention int64,
	value string) {
	var body types.TransformationRuleRequest
	if aggregateOnTransformationType == true {
		if len(aggregateOn) > 0 {
			transformation := types.DimensionTransformation{
				TransformationType: "AggregateOnTransformation",
				AggregateOn:        aggregateOn,
			}
			body.RuleDefinition.DimensionTransformations = append(body.RuleDefinition.DimensionTransformations, transformation)
		} else {
			fmt.Println("When using --aggregateOnTransformationType please ensure --aggregateOn is set.")
		}
	}
	if addOrReplaceTransformationType == true {
		if dimensionToReplace != "" && value != "" {
			transformation := types.DimensionTransformation{
				TransformationType: "AddOrReplaceTransformation",
				DimensionToReplace: dimensionToReplace,
				Value:              value,
			}
			body.RuleDefinition.DimensionTransformations = append(body.RuleDefinition.DimensionTransformations, transformation)
		} else {
			fmt.Println("When using --addOrReplaceTransformationType please ensure --dimensionToReplace and --value are set.")
			os.Exit(1)
		}
	}
	body.Enabled = enabled
	body.RuleDefinition.Name = name
	body.RuleDefinition.Retention = retention
	body.RuleDefinition.Selector = selector
	body.RuleDefinition.TransformedMetricsRetention = transformedMetricsRetention
	data, response, err := client.CreateTransformationRule(body)
	if err != nil {
		cmdutils.OutputError(response, err)
	} else {
		cmdutils.Output(data, response, err, "")
	}
}
